From c17fde87dcbe6b6ef2dc00cf3c9c8980d00fb711 Mon Sep 17 00:00:00 2001
From: "Okuniewska, Julia" <julia.okuniewska@intel.com>
Date: Wed, 3 Sep 2025 11:33:05 +0000
Subject: [PATCH] amcl: add disable laser control msgs

---
 include/nav2_amcl/amcl_node.hpp |  32 +++++++
 src/amcl_node.cpp               | 145 +++++++++++++++++++++++++++++++-
 2 files changed, 175 insertions(+), 2 deletions(-)

diff --git a/include/nav2_amcl/amcl_node.hpp b/include/nav2_amcl/amcl_node.hpp
index 514bba4c..e6ca231a 100644
--- a/include/nav2_amcl/amcl_node.hpp
+++ b/include/nav2_amcl/amcl_node.hpp
@@ -28,6 +28,7 @@
 #include <utility>
 #include <vector>
 
+#include "geometry_msgs/msg/pose_array.hpp"
 #include "geometry_msgs/msg/pose_stamped.hpp"
 #include "message_filters/subscriber.h"
 #include "nav2_util/lifecycle_node.hpp"
@@ -43,6 +44,9 @@
 #include "tf2_ros/transform_listener.h"
 #include "pluginlib/class_loader.hpp"
 
+#include "nav2_msgs/srv/global_localization.hpp"
+#include "nav2_msgs/srv/clear_entire_costmap.hpp"
+
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wunused-parameter"
 #pragma GCC diagnostic ignored "-Wreorder"
@@ -112,6 +116,9 @@ protected:
   rclcpp::executors::SingleThreadedExecutor::SharedPtr executor_;
   std::unique_ptr<nav2_util::NodeThread> executor_thread_;
 
+  bool force_publication = false;
+  bool sensor_disabled_ = false;
+
   // Pose hypothesis
   typedef struct
   {
@@ -204,6 +211,10 @@ protected:
    */
   void initServices();
   rclcpp::Service<std_srvs::srv::Empty>::SharedPtr global_loc_srv_;
+  rclcpp::Service<nav2_msgs::srv::GlobalLocalization>::SharedPtr fast_global_loc_srv_;
+  rclcpp::Client<nav2_msgs::srv::ClearEntireCostmap>::SharedPtr clear_entire_costmap_;
+  rclcpp::Service<std_srvs::srv::Empty>::SharedPtr disable_laser_;
+  rclcpp::Service<std_srvs::srv::Empty>::SharedPtr enable_laser_;
   /*
    * @brief Service callback for a global relocalization request
    */
@@ -212,6 +223,21 @@ protected:
     const std::shared_ptr<std_srvs::srv::Empty::Request> request,
     std::shared_ptr<std_srvs::srv::Empty::Response> response);
 
+  void fastGlobalLocalizationCallback(
+    const std::shared_ptr<rmw_request_id_t> request_header,
+    const std::shared_ptr<nav2_msgs::srv::GlobalLocalization::Request> & request,
+    std::shared_ptr<nav2_msgs::srv::GlobalLocalization::Response> response);
+
+  void disableLaserCallback(
+    const std::shared_ptr<rmw_request_id_t> request_header,
+    const std::shared_ptr<std_srvs::srv::Empty::Request> request,
+    std::shared_ptr<std_srvs::srv::Empty::Response> response);
+
+  void enableLaserCallback(
+    const std::shared_ptr<rmw_request_id_t> request_header,
+    const std::shared_ptr<std_srvs::srv::Empty::Request> request,
+    std::shared_ptr<std_srvs::srv::Empty::Response> response);
+
   // service server for providing an initial pose guess
   rclcpp::Service<nav2_msgs::srv::SetInitialPose>::SharedPtr initial_guess_srv_;
   /*
@@ -234,6 +260,7 @@ protected:
 
   // Nomotion update control. Used to temporarily let amcl update samples even when no motion occurs
   std::atomic<bool> force_update_{false};
+  std::atomic<bool> force_update_ON{false};
 
   // Odometry
   /*
@@ -266,6 +293,11 @@ protected:
    * @brief Pose-generating function used to uniformly distribute particles over the map
    */
   static pf_vector_t uniformPoseGenerator(void * arg);
+  static pf_vector_t fastUniformPoseGenerator(void * arg);
+  static std::vector<double> centerX_;
+  static std::vector<double> centerY_;
+  static std::vector<double> sigma_;
+  static std::vector<double> weight_;
   pf_t * pf_{nullptr};
   bool pf_init_;
   pf_vector_t pf_odom_pose_;
diff --git a/src/amcl_node.cpp b/src/amcl_node.cpp
index 88e28e29..5b3337b6 100644
--- a/src/amcl_node.cpp
+++ b/src/amcl_node.cpp
@@ -54,6 +54,12 @@
 using namespace std::placeholders;
 using rcl_interfaces::msg::ParameterType;
 using namespace std::chrono_literals;
+using namespace std;
+
+std::vector<double> nav2_amcl::AmclNode::centerX_;
+std::vector<double> nav2_amcl::AmclNode::centerY_;
+std::vector<double> nav2_amcl::AmclNode::sigma_;
+std::vector<double> nav2_amcl::AmclNode::weight_;
 
 namespace nav2_amcl
 {
@@ -332,8 +338,11 @@ AmclNode::on_cleanup(const rclcpp_lifecycle::State & /*state*/)
   // Get rid of the inputs first (services and message filter input), so we
   // don't continue to process incoming messages
   global_loc_srv_.reset();
+  fast_global_loc_srv_.reset();
   initial_guess_srv_.reset();
   nomotion_update_srv_.reset();
+  disable_laser_.reset();
+  enable_laser_.reset();
   initial_pose_sub_.reset();
   laser_scan_connection_.disconnect();
   tf_listener_.reset();  //  listener may access lase_scan_filter_, so it should be reset earlier
@@ -445,6 +454,34 @@ AmclNode::getOdomPose(
   return true;
 }
 
+double randomNum(double min, double max)
+{
+  return min + (max - min) * ((double)rand() / RAND_MAX);
+}
+
+void generateRandomGaussian(
+  const std::vector<double> & centerX,
+  const std::vector<double> & centerY,
+  const std::vector<double> & sigma,
+  const std::vector<double> & weight,
+  double & x,
+  double & y)
+{
+  int numCenter = centerX.size();
+  double u = randomNum(0.0, 1.0);
+  double cumWeight = 0.0;
+  for (int i = 0; i < numCenter; i++) {
+    cumWeight += weight[i];
+    if (u < cumWeight) {
+      double r = sqrt(-2.0 * log(randomNum(0.0, 1.0))) * sigma[i];
+      double theta = 2.0 * M_PI * randomNum(0.0, 1.0);
+      x = centerX[i] + r * cos(theta);
+      y = centerY[i] + r * sin(theta);
+      break;
+    }
+  }
+}
+
 pf_vector_t
 AmclNode::uniformPoseGenerator(void * arg)
 {
@@ -484,6 +521,44 @@ AmclNode::uniformPoseGenerator(void * arg)
   return p;
 }
 
+pf_vector_t
+AmclNode::fastUniformPoseGenerator(void * arg)
+{
+  map_t * map = reinterpret_cast<map_t *>(arg);
+
+  unsigned int rand_index = drand48() * free_space_indices.size();
+  AmclNode::Point2D free_point = free_space_indices[rand_index];
+  pf_vector_t p;
+  p.v[0] = MAP_WXGX(map, free_point.x);
+  p.v[1] = MAP_WYGY(map, free_point.y);
+  p.v[2] = drand48() * 2 * M_PI - M_PI;
+  double x, y;
+  generateRandomGaussian(centerX_, centerY_, sigma_, weight_, x, y);
+  p.v[0] = x;
+  p.v[1] = y;
+  return p;
+}
+
+void
+AmclNode::disableLaserCallback(
+  const std::shared_ptr<rmw_request_id_t>/*request_header*/,
+  const std::shared_ptr<std_srvs::srv::Empty::Request>/*req*/,
+  std::shared_ptr<std_srvs::srv::Empty::Response>/*res*/)
+{
+  sensor_disabled_ = true;
+  return;
+}
+
+void
+AmclNode::enableLaserCallback(
+  const std::shared_ptr<rmw_request_id_t>/*request_header*/,
+  const std::shared_ptr<std_srvs::srv::Empty::Request>/*req*/,
+  std::shared_ptr<std_srvs::srv::Empty::Response>/*res*/)
+{
+  sensor_disabled_ = false;
+  return;
+}
+
 void
 AmclNode::globalLocalizationCallback(
   const std::shared_ptr<rmw_request_id_t>/*request_header*/,
@@ -502,6 +577,30 @@ AmclNode::globalLocalizationCallback(
   pf_init_ = false;
 }
 
+void
+AmclNode::fastGlobalLocalizationCallback(
+  const std::shared_ptr<rmw_request_id_t>/*request_header*/,
+  const std::shared_ptr<nav2_msgs::srv::GlobalLocalization::Request> & request,
+  std::shared_ptr<nav2_msgs::srv::GlobalLocalization::Response>/*response*/)
+{
+  std::lock_guard<std::recursive_mutex> cfl(mutex_);
+
+  RCLCPP_INFO(get_logger(), "Initializing with uniform distribution");
+  centerX_ = request->center_x;
+  centerY_ = request->center_y;
+  sigma_ = request->sigma;
+  weight_ = request->weights;
+
+  pf_init_model(
+    pf_, (pf_init_model_fn_t)AmclNode::fastUniformPoseGenerator,
+    reinterpret_cast<void *>(map_));
+  RCLCPP_INFO(get_logger(), "Global initialisation done!");
+  initial_pose_is_known_ = true;
+  pf_init_ = false;
+  force_update_ON = true;
+  // force_publication = true;
+}
+
 void
 AmclNode::initialPoseReceivedSrv(
   const std::shared_ptr<rmw_request_id_t>/*request_header*/,
@@ -527,6 +626,8 @@ AmclNode::initialPoseReceived(geometry_msgs::msg::PoseWithCovarianceStamped::Sha
 {
   std::lock_guard<std::recursive_mutex> cfl(mutex_);
 
+  if (sensor_disabled_) {return;}
+
   RCLCPP_INFO(get_logger(), "initialPoseReceived");
 
   if (!nav2_util::validateMsg(*msg)) {
@@ -669,7 +770,7 @@ AmclNode::laserReceived(sensor_msgs::msg::LaserScan::ConstSharedPtr laser_scan)
   }
 
   pf_vector_t delta = pf_vector_zero();
-  bool force_publication = false;
+  // bool force_publication = false;
   if (!pf_init_) {
     // Pose at last filter update
     pf_odom_pose_ = pose;
@@ -701,6 +802,7 @@ AmclNode::laserReceived(sensor_msgs::msg::LaserScan::ConstSharedPtr laser_scan)
     updateFilter(laser_index, laser_scan, pose);
 
     // Resample the particles
+    // resample_interval_ = 20;
     if (!(++resample_count_ % resample_interval_)) {
       pf_update_resample(pf_, reinterpret_cast<void *>(map_));
       resampled = true;
@@ -788,7 +890,28 @@ bool AmclNode::shouldUpdateFilter(const pf_vector_t pose, pf_vector_t & delta)
   bool update = fabs(delta.v[0]) > d_thresh_ ||
     fabs(delta.v[1]) > d_thresh_ ||
     fabs(delta.v[2]) > a_thresh_;
-  update = update || force_update_;
+  // Re-localized successfully
+  if (force_update_ON &&
+    pf_->sets->cov.m[0][0] < 0.1 &&
+    pf_->sets->cov.m[1][1] < 0.1 &&
+    pf_->sets->cov.m[2][2] < M_PI / 8)
+  {
+    force_update_ON = false;
+      // force_publication = false;
+    force_publication = true;
+      // clear costmap
+    auto request = std::make_shared<nav2_msgs::srv::ClearEntireCostmap::Request>();
+    while (!clear_entire_costmap_->wait_for_service(1s)) {
+      if (!rclcpp::ok()) {
+        RCLCPP_ERROR(rclcpp::get_logger("rclcpp"),
+            "Interrupted while waiting for the service. Exiting.");
+      }
+      RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "service not available, waiting again...");
+    }
+    auto result = clear_entire_costmap_->async_send_request(request);
+  }
+
+  update = update || force_update_ || force_update_ON;
   return update;
 }
 
@@ -877,6 +1000,7 @@ void
 AmclNode::publishParticleCloud(const pf_sample_set_t * set)
 {
   // If initial pose is not known, AMCL does not know the current pose
+  force_publication = false;
   if (!initial_pose_is_known_) {return;}
   auto cloud_with_weights_msg = std::make_unique<nav2_msgs::msg::ParticleCloud>();
   cloud_with_weights_msg->header.stamp = this->now();
@@ -1577,9 +1701,26 @@ AmclNode::initServices()
     "set_initial_pose",
     std::bind(&AmclNode::initialPoseReceivedSrv, this, _1, _2, _3));
 
+  std::function<void(const std::shared_ptr<rmw_request_id_t>,
+    const std::shared_ptr<nav2_msgs::srv::GlobalLocalization::Request>,
+    std::shared_ptr<nav2_msgs::srv::GlobalLocalization::Response>)> fcn2;
+  fcn2 = std::bind(&AmclNode::fastGlobalLocalizationCallback, this, _1, _2, _3);
+  fast_global_loc_srv_ = this->create_service<nav2_msgs::srv::GlobalLocalization>(
+    "fast_global_localization", fcn2);
+  clear_entire_costmap_ = this->create_client<nav2_msgs::srv::ClearEntireCostmap>(
+    "global_costmap/clear_entirely_global_costmap");
+
   nomotion_update_srv_ = create_service<std_srvs::srv::Empty>(
     "request_nomotion_update",
     std::bind(&AmclNode::nomotionUpdateCallback, this, _1, _2, _3));
+
+  disable_laser_ = create_service<std_srvs::srv::Empty>(
+    "disable_laser",
+    std::bind(&AmclNode::disableLaserCallback, this, _1, _2, _3));
+
+  enable_laser_ = create_service<std_srvs::srv::Empty>(
+    "enable_laser",
+    std::bind(&AmclNode::enableLaserCallback, this, _1, _2, _3));
 }
 
 void
-- 
2.34.1

